var m=class{_cache=new Map;set(t,e,s=3e5){let r=Date.now();this._cache.set(t,{data:e,timestamp:r,expiresAt:r+s})}get(t){let e=this._cache.get(t);return e?Date.now()>e.expiresAt?(this._cache.delete(t),null):e.data:null}clear(){this._cache.clear()}isExpired(t){let e=this._cache.get(t);return!e||Date.now()>e.expiresAt}},g=new m;async function y(l,t,e=3){let s;for(let r=1;r<=e;r++)try{let a=await fetch(l,t);if(a.status>=400&&a.status<500&&a.status!==429)return a;if(a.status>=500||a.status===429){if(r===e)return a;let o=Math.min(1e3*Math.pow(2,r-1),1e4);await new Promise(i=>setTimeout(i,o));continue}return a}catch(a){if(s=a,r===e)throw s;let o=Math.min(1e3*Math.pow(2,r-1),1e4);await new Promise(i=>setTimeout(i,o))}throw s}var f=class{_baseUrl;_token;constructor(t,e="https://gitlab.com"){this._token=t,this._baseUrl=e}get _headers(){return console.log("GitLab API token info:",{tokenLength:this._token.length,tokenPrefix:this._token.substring(0,10)+"...",tokenType:this._token.startsWith("glpat-")?"personal-access-token":"unknown"}),{"Content-Type":"application/json","PRIVATE-TOKEN":this._token}}async _request(t,e={}){let s=`${this._baseUrl}/api/v4${t}`;return y(s,{...e,headers:{...this._headers,...e.headers}})}async getUser(){let t=await this._request("/user");if(!t.ok){let a=`Failed to fetch user: ${t.status}`;t.status===401?a="401 Unauthorized: Invalid or expired GitLab access token. Please check your token and ensure it has the required scopes (api, read_repository).":t.status===403?a="403 Forbidden: GitLab access token does not have sufficient permissions.":t.status===404?a="404 Not Found: GitLab API endpoint not found. Please check your GitLab URL configuration.":t.status===429&&(a="429 Too Many Requests: GitLab API rate limit exceeded. Please try again later.");try{let o=await t.json();o.message&&(a+=` Details: ${o.message}`)}catch{}throw new Error(a)}let e=await t.json(),s={limit:parseInt(t.headers.get("ratelimit-limit")||"0"),remaining:parseInt(t.headers.get("ratelimit-remaining")||"0"),reset:parseInt(t.headers.get("ratelimit-reset")||"0")};return{...{...e,avatar_url:e.avatar_url||e.avatarUrl||e.profile_image_url||null},rateLimit:s}}async getProjects(t=!0,e=20,s=50){let r=`projects_${this._token}_${t}_${e}`,a=g.get(r);if(a)return a;let o=[],i=1,u=10;for(;i<=u;){let n=await this._request(`/projects?membership=${t}&min_access_level=${e}&per_page=${s}&page=${i}&order_by=updated_at&sort=desc`);if(!n.ok){let d=`Failed to fetch projects: ${n.status} ${n.statusText}`;try{let p=await n.json();console.error("GitLab projects API error:",p),d=`Failed to fetch projects: ${JSON.stringify(p)}`}catch(p){console.error("Could not parse GitLab error response:",p)}throw new Error(d)}let h=await n.json();if(h.length===0||(o=[...o,...h],o.length>=100))break;i++}let c=o.map(n=>({id:n.id,name:n.name,path_with_namespace:n.path_with_namespace,description:n.description,http_url_to_repo:n.http_url_to_repo,star_count:n.star_count,forks_count:n.forks_count,default_branch:n.default_branch,updated_at:n.updated_at,visibility:n.visibility}));return g.set(r,c),c}async getEvents(t=10){let e=await this._request(`/events?per_page=${t}`);if(!e.ok)throw new Error(`Failed to fetch events: ${e.statusText}`);return(await e.json()).slice(0,5).map(r=>({id:r.id,action_name:r.action_name,project_id:r.project_id,project:r.project,created_at:r.created_at}))}async getGroups(t=10){let e=await this._request(`/groups?min_access_level=${t}`);return e.ok?await e.json():[]}async getSnippets(){let t=await this._request("/snippets");return t.ok?await t.json():[]}async createProject(t,e=!1){let s=t.replace(/[^a-zA-Z0-9-_.]/g,"-").replace(/-+/g,"-").replace(/^-|-$/g,"").toLowerCase(),r=await this._request("/projects",{method:"POST",body:JSON.stringify({name:s,path:s,visibility:e?"private":"public",initialize_with_readme:!1,default_branch:"main",description:"Project created from Bolt.diy"})});if(!r.ok){let a=`Failed to create project: ${r.status} ${r.statusText}`;try{let o=await r.json();o.message&&(typeof o.message=="object"?a=`Failed to create project: ${Object.entries(o.message).map(([u,c])=>`${u}: ${Array.isArray(c)?c.join(", "):c}`).join("; ")}`:a=`Failed to create project: ${o.message}`)}catch(o){console.error("Could not parse error response:",o)}throw new Error(a)}return await r.json()}async getProject(t,e){let s=await this._request(`/projects/${encodeURIComponent(`${t}/${e}`)}`);return s.ok?await s.json():null}async createBranch(t,e,s){let r=await this._request(`/projects/${t}/repository/branches`,{method:"POST",body:JSON.stringify({branch:e,ref:s})});if(!r.ok)throw new Error(`Failed to create branch: ${r.statusText}`);return await r.json()}async commitFiles(t,e){let s=await this._request(`/projects/${t}/repository/commits`,{method:"POST",body:JSON.stringify(e)});if(!s.ok){let r=`Failed to commit files: ${s.status} ${s.statusText}`;try{let a=await s.json();a.message?r=a.message:a.error&&(r=a.error)}catch{}throw new Error(r)}return await s.json()}async getFile(t,e,s){return this._request(`/projects/${t}/repository/files/${encodeURIComponent(e)}?ref=${s}`)}async getProjectByPath(t){try{let e=encodeURIComponent(t),s=await this._request(`/projects/${e}`);if(s.ok)return await s.json();if(s.status===404)return console.log(`Project not found: ${t}`),null;let r=await s.text();throw console.error(`Failed to fetch project ${t}:`,s.status,r),new Error(`Failed to fetch project: ${s.status} ${s.statusText}`)}catch(e){if(e instanceof Error&&(e.message.includes("404")||e.message.includes("Not Found")))return null;throw e}}async updateProjectVisibility(t,e){let s=await this._request(`/projects/${t}`,{method:"PUT",body:JSON.stringify({visibility:e})});if(!s.ok)throw new Error(`Failed to update project visibility: ${s.status} ${s.statusText}`)}async createProjectWithFiles(t,e,s){let r=await this.createProject(t,e);if(Object.keys(s).length>0){await new Promise(i=>setTimeout(i,1e3));let o={branch:"main",commit_message:"Initial commit from Bolt.diy",actions:Object.entries(s).map(([i,u])=>({action:"create",file_path:i,content:u}))};try{await this.commitFiles(r.id,o)}catch(i){console.error("Failed to commit files to new project:",i)}}return r}async updateProjectWithFiles(t,e){if(Object.keys(e).length===0)return;let r={branch:"main",commit_message:"Update from Bolt.diy",actions:Object.entries(e).map(([a,o])=>({action:"create",file_path:a,content:o}))};try{await this.commitFiles(t,r)}catch(a){if(a instanceof Error&&a.message.includes("already exists")){let i={branch:"main",commit_message:"Update from Bolt.diy",actions:Object.entries(e).map(([u,c])=>({action:"update",file_path:u,content:c}))};await this.commitFiles(t,i)}else throw a}}};export{g as a,f as b};
